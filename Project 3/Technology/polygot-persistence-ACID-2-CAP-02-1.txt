Capability Matrix In the begining Structured was it! Structured Data Why was it so? Computers barely existed! There were no networks! No browsers! Not considered social! All data was generated by Business applications and they had the structure etc PoS and reservation systems Progression http://www.computerbusinessresearch.com/Timeline http://www.computerbusinessresearch.com/Home/database/network-database-model Onto Relational Model Comparison For relational databases E/R is the essential piece. Schema is essential. Schema cannot change often Expensive task. Business evolves  structure and Semantics of data changes RDB -- ideal for transactional systems Distributed Concurrent ACID When the internet took hold, people to people communications emerged  social exchange.and that is not structured unstructured data dominates today  structured data volume is still essential but a fractionthis will continue FB etc faced extreme difficulties trying to work with RDB Comes along BASE and CAP  Schemaless dataStores without ACID Inside a RDBMS Engine https://www.youtube.com/watch?v=Z_cX3bzkEx E https://www.youtube.com/watch?v=C_Uv_4I9gus https://www.youtube.com/watch?v=vAHZjOLmu1g https://www.youtube.com/watch?v=C_Uv_4I9gus Issues With RDBMS Issues Incompatibilities One size does not fit ALL World is NOT tabular tabular to business object translation Does not keep up with high velocity data UnStructured Putting them all together   Threading a narrative/story Introduction to Unstructured data NOSQL  Not Only SQL Engines Introduction to mongo Columnar http://www.youtube.com/watch?v=8KGVFB3kVHQIntro to Columnar: https://www.youtube.com/watch?v=wYl_YxqTof4 https://www.youtube.com/watch?v=mRvkikVuoj U There is no benefit to Columnar approach to manipulate single row or operations one row at a time. Writes (updating) are NOT trivial and not suitable for Columnar Columnar database is not suitable for OLTP http://www.youtube.com/watch?v=8KGVFB3kVHQ Structure of Data Table/column  relational Name/value pairs  ndbm ++ Document Oriented  mongodb Graph databases  neo4j Wide column  cassandra TimeSeries XML/json databases History Pre-WWW Data is transactional ACID/RDBMS rules Advent of WWW Email+FTP+Image +MP3+A/V Mostly p2p comm Usenet Groups, broadcast,list Social Communication CSCW Youtube Facebook twitter Have we seen it all? Is this the end? Cognitive and contextual computing Transactional data used to be the bulk of the data  impersonal, not people oriented, structured, text Now, it is ALL unstructured, mostly human-oriented, Unstructured, and variety multimedia stream Siesmic Shift And Moore's Law effect  faster computer, faster network Netflix is streaming movies on par with theater experience Dynamic structure Structure is not static Changes Unmanageable volumes At speeds never Anticipated Interactions are long lived RDBMS cannot handle. Give up Schema Give up Structure Give up Transaction trade ACID for CAP Hello (n silent for hell no) It just started  it will never be over  pace of new technological innovation is accelerating Drones, geolocation, smart delivery Skies will be crowded Man made eclipse when there is a snarl IoT internet of things Talking humans  talking devices, cars Nothing is listening everything is talking Cognitive Computing Intelligent human compatible computing Imagine which car said what to which car after a pile up Insurance companies Where is the black box? Paste is out of the tube..cannot start over.. it will never be the same Crowded Place Polyglot Persistence https://www.mapr.com/products/polyglot- persistence Reference Architecture http://nosql.mypopescu.com/post/4017169246/polyglot-persistence-the-architecture-of- the Polyglot Persistence http://architects.dzone.com/articles/martin-fowler- polyglot Thinking out of the box Interesting read http://www.infoworld.com/article/2616126/ Application-development/ 10-things-never-to-do-with-a-relational-database.html If you need a plane, stapling a flock of birds to a truck is not a strategy http://arnoldit.com/wordpress/2008/06/28/ idcs-database-market-share-analysis/ RDBMS  19 billion dollar ostrich (It aint dead yet..) http://www.infoworld.com/article/2617876/database/ which-freaking-database-should-i-use-.html http://download.microsoft.com/download/6/C/D/ 6CDC123B-A159-438C-BBAD-7750EE5D0D67/ IDC-Server%20Workloads%20Forecast.pdf http://arnoldit.com/wordpress/2008/06/28/ What is NoSQL  Not only SQL  Many variant  Document oriented  Graph database  Key/value  Wide column  Mongo  document oriented  Hu-mongo-us  No transaction / no acid / no schema / no relation more  CAP not ACID  Eventually consistent  Document --> record  Operation on one document is atomic  No partial update to a single document Resources http://docs.mongodb.org/manual/tutorial/write-scripts-for-the-mongo-shell/ http://howtodoinjava.com/2014/05/26/introduction-to-mongodb-why-mongodb/ http://docs.mongodb.org/manual/core/introduction/ http://howtodoinjava.com/2014/05/29/mongodb-selectqueryfind-documents-examples/ http://jandiandme.blogspot.com/search/label/CAP%20Theorem http://jandiandme.blogspot.de/2013/06/mongodb-and-cap-theorem.html http://info.mongodb.com/rs/mongodb/images/10gen_Top_5_NoSQL_Considerations.pdf http://css.dzone.com/articles/how-acid-mongodb http://docs.mongodb.org/manual/tutorial/getting-started/ http://www.mkyong.com/mongodb/how-to-install-mongodb-on-mac-os-x/ http://docs.mongodb.org/manual/reference/operator/#comparison http://www.mkyong.com/mongodb/mongodb-authentication-example/ http://www.mkyong.com/mongodb/how-to-install-mongodb-on-mac-os-x/ ACID Gone with the Wind! CAP CAP Theorem http://ivoroshilin.com/2012/12/13/brewers-cap-theorem-explained-base-versus- acid/ Definitions Consistency: A service that is consistent should follow the rule of ordering for updates that spread across all replicas in a cluster  what you write is what you read, regardless of location. For example, Client A writes 1 then 2 to location X, Client B cannot read 2 followed by 1. This rule has another name Strong consistency. Availability: A service should be available. There should be a guarantee that every request receives a response about whether it was successful or failed. If the system is not available it can be still consistent. However, consistency and availability cannot be achieved at the same time. This means that one has two choices on what to leave. Relaxing consistency will allow the system to remain highly available under the partitioning conditions (see next definition) and strong consistency means that under certain conditions the system will not be available. Partition tolerance: The system continues to operate despite arbitrary message loss or failure of part of the system. A simple example, when we have a cluster of N replicated nodes and for some reason a network is unavailable among some number of nodes (e.g. a network cable got chopped). This leads to inability to synchronize data. Thus, only some part of the system doesnt work, the other one does. If you have a partition in your network, you lose either consistency (because you allow updates to both sides of the partition) or you lose availability (because you detect the error and shut down the system until the error condition is resolved). BASE A simple meaning of this theorem is It is impossible for a protocol to guarantee both consistency and availability in a partition prone distributed system. Eventual consistency (BASE) The term eventual consistency or as it is called BASE (Basically Available, Soft state, Eventual consistency) is the opposite of ACID (Atomicity, Consistency, Isolation and Durability). Where ACID is pessimistic and requires consistency at the end of every operation, BASE is optimistic and accepts that the database consistency will be in a state of flux. The eventual consistency is simply an acknowledgement that there is an unbounded delay in propagating a change made on one machine to all the other copies which might lead to stale data. Node/Read/Write NRW (Node, Read, Write) allows to analyse and tune how a distributed database will trade off consistency, read / write performance. N = the number of nodes that keep copies of a record distributed to. W = the number of nodes that must successfully acknowledge a write to be successfully committed. R = the number of nodes that must send back the same value of a unit of data for it to be accepted as read by the system. The majority of NoSQL databases use N>W>1  more than one write must complete, but not all nodes need to be updated immediately. When: W < N  high write availability R < N  high read availability W+R > N  is a strong consistency, read/write are fully overlapped W+R <= N  is an eventual consistency, meaning that there is no overlap in the read and write set; Off to the races http://docs.mongodb.org/manual/tutorial/query- documents/ No relations  no joins Object embedding Object ID Reference This needs to be resolved. Lingo: JSON Javascript object notation http://json.org/ & http://stackoverflow.com for doubts http://www.freeformatter.com/json-formatter.html#json-explained http://www.freeformatter.com/json-validator.html#json-explained http://json.org/ http://www.freeformatter.com/json-formatter.html#json-explained useless example "arrayOfIntegers": [ 1, 2, 3, 4, 5 ] } { "anObject": { "numericProperty": -122, "stringProperty": "An offensive \" is problematic", "nullProperty": null, "booleanProperty": true, "dateProperty": "2011-09-23" }, "arrayOfObjects": [ { "item": 1 }, { "item": 2 }, { "item": 3 } ], {example:"value"} is invalid but {"example":"value"} is valid. Useful examples db.filters.insert({ class:"stateless", type:"BasicFilter", name:"BF01", ... predicate: [ {T:"35", op:"EQ", value: [ "D" ]} , {T:"55",op:"EQ", value: ["IBM","ABB","CSCO"]} ] } ); book1 = {name: "Understanding JAVA", pages : 100} db.books.save(book1) msgs fp p MKT steps http://docs.mongodb.org/manual/ http://www.mongodb.org/downloads Then (appraise yourself with install etc) Minimal configuration Starting and Stopping and A few basic commands Setup: install and verify Here mongod is the server and mongo is the shell client Starting the server Data is mine I dont want to loose if my windoooz goes down on me. Data is in E drive and I can reinstall mongodb in C as many times as I want to without loosing my data The default port on which mongod serves is data is 27017. You can configure both these using a conf file... Start mongod with the dbpath option Stopping and admin db use admin db.shutdownServer({timeoutSecs: 60}); Create a db directory Start mongod with the dbpath option Stopping the server config fork = true bind_ip = 127.0.0.1 port = 27017 quiet = true dbpath = e:\mongodb\data\db logpath = e:\mongodb\log\mongodb\mongod.log logappend = true journal = true Working with PD Software is about patience and T/E. You cannot give up. Fork option did not work. My config does not have it Preparing your DB I have stored the config file in e:\mongodb  can be anywhere I am directing all logs as specfied in the config file file:///e:/mongodb reconnect Start the server with the config option Changing DB Same as mysql!! C in CRUD http://docs.mongodb.org/manual/reference/operators/#comparison http://docs.mongodb.org/manual/core/shell-types/ {symbolname:"IPFF", date:"2013-04-12",open:"27.05", high:"27.05",low:"26.81",close:"26.86",volume:"35300", adjClose:"26.86"} db.ticks.save({symbolname:"IPFF"}) db.ticks.save({symbolname:"IPFF", date:"2013-04-12", open:"27.05",high:"27.05",low:"26.81",close:"26.86", volume:"35300",adjClose:"26.86"}) http://docs.mongodb.org/manual/reference/operators/#comparison db.ticks.find() db.ticks.find({"high:{$gt:2}"}) -- WILL NOT WORK db.ticks.find({high:"27.05"}) db.ticks.find({symbolname:"IPFF"}) db.ticks.save({symbolname:"IPFF", date:"2013-04- 12",open:27.05,high:27.05,low:26.81,close:26.86, volume:35300,adjClose:26.86}) db.ticks.find({high:27.05}) db.ticks.find({high:"27.05"}) db.ticks.find({high:{$gt:27.05}}) db.ticks.find({high:{$gt:27.0}}) More Steps db.ticks.distinct("symbolname") db.doctor.update([symbolname:"IPFF"],[$set:[high: 28.02]]) db.ticks.remove(symbolname:"IPFF") CRUD db.execs.find({},{_id:0},{$sort:{px:1}}) { "ticker" : "IBM", "qty" : "100", "px" : "202" } { "ticker" : "IBM", "qty" : "100", "px" : "203" } { "ticker" : "IBM", "qty" : "200", "px" : "198.50" } { "ticker" : "IBM", "qty" : "200", "px" : "199.50" } { "ticker" : "IBM", "qty" : "200", "px" : "199.90" } db.execs.find({},{_id:0}) { "ticker" : "IBM", "qty" : "100", "px" : "202" } { "ticker" : "IBM", "qty" : "100", "px" : "203" } { "ticker" : "IBM", "qty" : "200", "px" : "198.50" } { "ticker" : "IBM", "qty" : "200", "px" : "199.50" } { "ticker" : "IBM", "qty" : "200", "px" : "199.90" } Loading mongoimport --db mydb --collection rktrades --type csv --headerline --file trades.js Sales collection db.sales.insert({ Year:2000, Region:"USA",Sales:400}) > db.sales.insert({ Year:2001, Region:"USA",Sales:200}) > db.sales.insert({ Year:2002, Region:"USA",Sales:400}) > db.sales.insert({ Year:2002, Region:"Europe",Sales:300}) > db.sales.insert({ Year:2003, Region:"Europe",Sales:100}) > db.sales.insert({ Year:2008, Region:"USA",Sales:500}) > db.sales.insert({ Year:2003, Region:"Asia",Sales:400}) > db.sales.count({Region:"UDS"}) 0 > db.sales.count({Region:"USA"}) 4 aggregate db.sales.group( { key: { Region: 1 }, cond: { Year: { $lt: 2005 } }, reduce: function(cur, result) { result.total += cur.Sales }, initial: { total: 0 } } ) Group By db.rktrades.group({key:{TKR:1},reduce:function(cur,result){result.total+= cur.QTY * cur.PX,result.totalQty+=cur.QTY}, initial:{total:0,totalQty:0}}) db.rktrades.group({key:{TKR:1,SIDE:1},reduce:function(cur,result) {result.total+=cur.QTY * cur.PX,result.totalQty+=cur.QTY}, initial:{total:0,totalQty:0}}) db.runCommand( { distinct: "sales", key:"Region", query:{Sales: {$gt:200}}}) Unstructured Data Types Unstructured data is raw and unorganized and organizations store it all. Ideally, all of this information would be converted into structured data however, this would be costly and time consuming. Also, not all types of unstructured data can easily be converted into a structured model. For example, an email holds information such as the time sent, subject, and sender (all uniform fields), but the content of the message is not so easily broken down and categorized. This can introduce some compatibility issues with the structure of a relational database system. Here is a limited list of types of unstructured data:  Emails  Word Processing Files  PDF files  Spreadsheets  Digital Images  Video  Audio  Social Media Posts Looking at the list, you may be wondering what these files have in common. The files listed above can be stored and managed without the format of the file being understood by the system. This allows them to be stored in an unstructured fashion because the contents of the files are unorganized. https://breakthroughanalysis.com/2008/08/01/unstructured- data-and-the-80-percent-rule/ [[https://www.bing.com/search?q=proportion+of+unstructure d+to+structured+data]] [[https://sherpasoftware.com/blog/structured-and- unstructured-data-what-is-it/]] Unstructured Data https://www.slideshare.net/camsemantics/introduction-to-anzo-unstructured Mark Logic/DataVarsity primer ACID BASE Datavarsity Eventual Consistency BASE/CAP The IEEE 610 definition of availability is the degree to which a system or component is operational and accessible when required for use by an authorized user.1 ACID constraints provide strong consistency, all the time, no matter what. Such requirements often have repercussions, though; especially regarding availability. If the system must always remain in a consistent state, so all parties see the same view of the data at the beginning and end of a transaction, then across thousands of nodes that data may not always be available. Where are we headed? Anzo Platform? Capability Matrix
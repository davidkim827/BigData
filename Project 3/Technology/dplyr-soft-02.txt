PowerPoint Presentation dplyr wordcloud(dplyr_verb$verbs,dplyr_verb$powe r,random.order=T,random.color=T,colors=c("bl ack","red","green","yellow","blue","orange"," magenta","pink","purple"),rot.per=.51) dplyr with pipe url<-"https://sites.google.com/site/pocketecoworld/sampledata.csv" dframe<-read.csv(url,sep=",",head=T) require(magrittr) # pipe %>% require(dplyr) dframe %>% filter( Index=='A') # without pipe filter(dframe,Index=='A') dframe %>% filter(Y2005>1200000 & Index=='A') # without pipe filter(dframe, Y2005>1200000 & Index=='A') Verbs of dplyr filter select summarize mutate arrange join group_by dplyr:select dframe %>% select( Index, State) Same as select(dframe,Index,State) Verbs of dplyr Filter select summarize Mutate arrange Join Group_by dplyr:combining verbs dframe %>% filter(Y2005>1200000 & Index=='A') %>% select (State,Y2002,Y2007,Y2008) select (filter(dframe,Y2005>1200000 & Index=='A') State,Y2002,Y2007,Y2008) Regular way Using magittr.pipe mutating (changing) dframe %>% filter(Index =='A') %>% select (State,Y2002,Y2004) %>% mutate(Y2002onY2004=Y2004/Y2002-1) Note that mutate creates a new variable (or column) Select NOT commutative!!!!!! with mutate or filter than dframe %>% mutate(Y2002onY2004=Y2004/Y2002-1) %>% select (State,Y2002,Y2004) %>% filter(Index =='A') ## WILL FAIL  WHY? ## AND what happened to my new variable. mutate(select(filter(dframe,Index=='A'),State,Y2002,Y2004), + Y2002onY2004=Y2004/Y2002-1) dframe %>% filter(Index =='A') %>% select (State,Y2002,Y2004) %>% mutate(Y2002onY2004=Y2004/Y2002-1) arrange:sorting dframe %>% filter (Index == 'A') %>% arrange(Y2002) %>% select (State,Y2002,Y2004) dframe %>% filter (Index == 'A') %>% arrange(desc(Y2002)) %>% select (State,Y2002,Y2004) select(arrange(filter(dframe,Index == 'A'),Y2002), State,Y2002,Y2004) summarize summarize_at(group_by(dframe,Index),vars(Y2 002:Y2004),funs(n(),mean(.,na.rm=TRUE))) dframe %>% group_by (Index) %>% summarize_at(vars(Y2002:Y2004), funs(n(),mean(.,na.rm=TRUE))) dframe %>% filter (Index %in% c("A","C","I")) %>% group_by (Index) %>% do(head(.,2)) Operating on subgroups t = mydata %>% select(Index, Y2015) %>% filter(Index %in% c("A", "C","I")) %>% group_by(Index) %>% do(arrange(.,desc(Y2015))) Loading titanic require(magrittr) require(dplyr) titanic<-read.csv("./titanic-train.csv",head=T) t_cc<-titanic[complete.cases(titanic),] # what difference does it make? dim(titanic) == dim(t_cc) #examine head(t_cc) #let us find the youngest and oldest person t_cc %>% group_by (Survived,Sex) %>% summarize_at(vars(Survived,Sex,Age), funs(n(),max(Age),min(Age),median(Age))) Group_by: processing each subgroup dplyr.group_by do(.) Join df2<-data.frame(name= c("john", "bill", "madison", "abby", "thomas"), gender=c("M", "either", "M", "either", "M"),stringsAsFactors = FALSE) df1<-data.frame(first_name = c("john", "bill", "madison", "abby", "zzz"), stringsAsFactors = FALSE) We will keep df2 for other experiments. We will copy df2 to df3 and make the names of df3 same as df1 and then do the inner_join A data science brain must ask many questions at this time!!! Join df2<-data.frame(name= c("john", "bill", "madison", "abby", "thomas"), gender=c("M", "either", "M", "either", "M"),stringsAsFactors = FALSE) df1<-data.frame(first_name = c("john", "bill", "madison", "abby", "zzz"), stringsAsFactors = FALSE) Join df2<-data.frame(name= c("john", "bill", "madison", "abby", "thomas"), gender=c("M", "either", "M", "either", "M"),stringsAsFactors = FALSE) df1<-data.frame(first_name = c("john", "bill", "madison", "abby", "zzz"), stringsAsFactors = FALSE) Join df2<-data.frame(name= c("john", "bill", "madison", "abby", "thomas"), gender=c("M", "either", "M", "either", "M"),stringsAsFactors = FALSE) df1<-data.frame(first_name = c("john", "bill", "madison", "abby", "zzz"), stringsAsFactors = FALSE) Random  uncorrelated x<-rnorm(100) y<-rnorm(100) What levels of correlation is acceptable between X and Y given they were randomly generated? cor(x,y) [1] 0.1480642 Is 14% correlation acceptable? 0% is perfectly uncorrelated. LMOBJ<-lm(y~x) R functions return somethingmostly gets evaluated by the R-Shell. Default evaluation is to print it to the console. Assigning to LMOBJ prevents further evaluation. Here lm returns an object and it is evaluated. Printing partially. We can suppress it with invisible. Inside R objects LMOBJ<-lm(y~x) R functions return somethingmostly gets evaluated by the R-Shell. Default evaluation is to print it to the console. Assigning to LMOBJ prevents further evaluation. Here lm returns an object and it is evaluated. Printing partially. We can suppress it with invisible. You just downloaded a great new package and you want to find what the package functions return. Let us start with good old OLS function lm. Inside an lm object:str(lmobj) LMOBJ$residuals == (LMOBJ$model$y - LMOBJ$fitted.values) Lm returns a list of 12 objects [1] "coefficients" [2] "residuals" [3] "effects" [4] "rank" [5] "fitted.values" [6] "assign" [7] "qr" [8] "df.residual" [9] "xlevels" [10] "call" [11] "terms" [12] "model" Basics in R:dissecting R Objects Dissecting lm SVD r1<-c(3, 1, 2, 5, 4, 1) r2<-c(4, 2, 3, 1, 1, 3) r3<-c(1, 5, 4, 2, 3, 2) r4<-c(3, 1, 2, 3, 0, 3) r5<-c(5, 4, 2, 2, 5, 1)